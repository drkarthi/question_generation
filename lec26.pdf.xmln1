That  software engineering processes, methods and methodologies which allow you to built software systems in a very streamlined manner but most of these have focused on the building of fairly a large software system and which there is a significant amount of design to be done, there is a significant requirement body of requirement that has been established, a specification has been written and so on and there is a typical process that you end up following to deliver systems of that kind.<s> But there may also be situations in which businesses need the turnaround time of software development to be very very small.<s> In other words, I need the product of the requirement at the end of specifying very very quickly because they are responding to a certain business need in turn and this necessitates a different model to be followed in the production of software and that is what agile development is all about.<p>

It is about trying to turn around requirements very very quickly may be in an incrementalmode; in fact most often in incremental mode so that there is some output at the end of avery short period and the rest of the output can follow behind that and we will take a looktoday at some of the processes  and  methodologies that we can use to turn softwarearound very very fast.<s> So the objectives of this part of this course is to basically explainhow an iterative incremental process is very very useful to deliver software quickly andwhat is the what are the aspects of such a process you know what are the considerationsto be followed in such a process  to explain the principles of a particular programmingmethodology called extreme programming and we will go into a little bit of detail aboutextreme programming which is one of the latest and one of the newest practices insoftware development and to explain the roles of what is called prototyping in this software development process.<p>


So why is software development rapid software development required and why is there aneed to turn something around very very quickly  whereas traditionally software wasconstructed the way that other things are constructed.<p>


For example, example if you are building a dam or if you are building a bridge across ariver there is no short cut method to be followed, you know, the bridge or the dam has to be designed,  measurements  have to be taken or the design has to be very carefullyvalidated to make sure that it is going to withstand the weight, the speed of the vehiclesthat are moving over it and so on  before construction has begun and there is no piece-meal construction of the structure either the structure is there and usable or it is not at allit is just a binary kind of a decision there.<p>

But in the case of software it need not be the case by the very nature of the name because there could be very rapidly changing business conditions that lead the business to make certain decisions so they have to respond so maybe there is a new opportunity round thecorner that they have to respond to maybe it is a new service that they wish to introducein say the telecommunications domain or there may competitors who are coming up with certain products that the business has to respond to in which case it may have to makechanges to its own products.<p>

So all of these requires a software development where  the  delivery is very very criticaland the delivery has to happen very quickly and so that requirement comes about and it isobviously often true  that there  has to be some compromise that is going to be madebetween the time that it takes to deliver a product and the quality of the product at the endof the day  as long as there is some software available to be rolled out  that shows theprogress  that shows the progress has  been  made and the  rest of it can come along in asequential manner then it is okay so there may be businesses that accept a slightly lowerstandard of quality in a shortest time cycle and quality can be improved as things goalong so may be non-functional requirements  may not be perfect,  it may not be able tocarry the same amount of load for example, the software but as time goes along we canimprove the performance, we can improve the reliability, we can improve the availabilityof the software as well.<p>

So, because of the changing nature of the environment and because of the rapid changesthat are taking place in the business environment it may not be possible always to arriveat  a  system requirements phase which can be called complete  in any sense of the termbefore you move on to system specification,  before you move on to functionalspecification design, development and testing and so on.<p>


So if the requirement themselves keep on changing and therefore the traditional waterfallmodels of development that we have seen so far is not very easy to follow that becausethere there is a presumption that the requirements phase is complete before you move onto the design phase or the specification phase of the software and that may not be possiblehere because requirements are coming in incrementally.<s> So the details of the new servicemay all be known,  the new server is going to be introduced and here the essentialcharacteristics of the service but the details of the characteristics may not be known andthat may come in as the project progresses and therefore iterative delivery of software isthe only way to handle changing requirements like this.<p>

So what are the characteristics and what are the fundamental of the essential nature of theagile process of development;  agile process basically refers to delivering softwarequickly.<p>


So one of the characteristics is that we just noticed that the requirements phase cannot becomplete before we move on to the other phases which means implicitly that these phasesare concurrent in nature so that the requirement specification phase, the design phase, thedevelopment phase and the test phase often may be concurrent with one another so alsothere is no detailed specification typically written out for this.<s> The design documentationcan be very minimal because you are moving very very quickly in order to get thesoftware out.<s> So the characteristics are that because of the incomplete  nature of therequirement, because of the change in requirement and because of the concurrency of thedifferent phases the system is usually delivered in increment; it is delivered in very verysmall increments  and every increment is completely enough  and  itself  has to beintegrated back into the main system as the project progresses.<p>

And  another very key feature is that because it is delivered in increment that is  the keyword here the users get to see sample and you know touch and  feel the software veryearly on the lifecycle  so that they can give feedback,  they can give suggestions  on  theimprovement in the existing software,  they can also tune the further requirements  thatthey are going to give in a way that is going to make it easy for you to construct the restof the software that is one thing.<p>
The  third and the last characteristic here is that user interfaces are  typically  developedvery early on  here to get user feedback and they can be developed using  an  interactiveparadigm.<s> So, for example there could be something which will allow you to change thepositions of the buttons, which are allow you to change the positions of the fonts, the textfeatures that you have to enter, the kinds of inputs that you have to give and all of these infact  be changed  on the fly as the user is experiencing using the software and thesechanges can be made permanent going forward.<p>


So an agile process is really focusing on what is called a rapid application developmentenvironment and the things that go along with that.<s> So what is an iterative development process?<s> Let us take a look at what the process itself looks like.<p>


We have drawn out the diagram here where you start out by defining the different systemvariables that can exist.<p>


Now,  once the architecture,  the system variables lead to a decision on  what kind ofarchitecture is to be employed,  so,  for example,  a pipes and filters architecture can beemployed,  a three tier  architecture can be  employed,  a rule based architecture can beemployed and so on.<s> Once  the architecture decision is made then the requirement thatexist after this point in time is  specified in a series of increment.<s> So,  for that incrementthat you are going to take a development on you specify what it is going to contain andonce that increment has been specified you go ahead and build the increment just like youdo in a normal software development process.<p>

Now what happens typically is once you finish development of the software you test it sothat step is exactly the same except that you are doing it for a very limited subsection ofthe requirement which is what exist within the increment and once the test and validationphase is complete the phase that exist here which is quite important and which is happening very often is an integration phase that may exist onlyonce during the lifecycle of a typical software development process which is non-agile innature.<s> Many of these can exist because this entire thing all the way from specifying theincrement,  all the way to testing the system can be a loop because you specify  many increments.<p>

Thus, once the integration phase is done we then have to test the entire system.<s> what we tested back here in the increment testing phase is your testing the code that was written during this particular increment;  you are testing the features  that were  supposed  to be built during this increment but then once you integrate with the rest of the software that exists you have to test the system as a  whole  and once the system as a  whole is tested then there is a question to be asked; now is the system complete or is the new increment to be specified.<s> If the system is complete then you move out of here to delivery of the system if the system is not complete then you go back tospecify the next increment within the process.<p>
