(Refer Slide Time: 40:39)<p>

So, some of the problems that component based software engineering face today are thatthere can be component incompatibilities;  you may get two components from twodifferent sources and there may be standards in compatibility that may exist; even thoughthey both provide the kind of functionality that you need one may be talking as slightlydifferent protocol than the other one and the glue that you may have to write now to bringthese things together may  prove quite expensive;  it may be in fact in some cases moreexpensive than writing the original piece of software from scratch so that is one thing thathas to be taken into account.<p>

The  other thing is the old problem of reuse that we already  saw which is finding andunderstanding  these  components.<s> So,  is there a standard means of describing  acomponent;  there is no component that exists  today  for example,  for describing what acomponent does even though there are designs there are defacto standards such as UMLthat is available there are no component based software engineering standards for sayinghere is a description of a component that can be  processed  by  a machine for examplewhile doing a search.<p>

The  third thing is managing evolution of systems.<s> If your system is largely built out ofpre-existing components and now the system specifications change the systemrequirements change,  the specifications  change  now you may end up in a bind becausethe existing components may not fit the new requirements  that you have,  the  slightlyextended requirement that you have and if no component is now available to match thoseneeds you have to write that piece of code from scratch, write that part of the system fromscratch and that can prove quite expensive so in some cases you would find out thatevolution of a system to support a slightly incremental requirement is much moreexpensive than the original system that was built and that does not look very good.<p>
