And finally  the law of conservation of familiarity is that if there are if there  is a largeamount  of change that is taken place from  one version of software to the next then theless familiar that you are going to end up becoming with the software because thesoftware as you knew it as an architect or designer is now no longer going to be how itexists.<s> So,  during the lifetime of a  program then the amount of change betweensuccessive releases has to be a constant and if that is you know widely varying then yourdegree of  familiarity with the  software goes down as a result of which the  maintenancecost  suddenly shoots  up because  you  now had to spend a lot more time trying  to figureout how this software is doing what it is supposed to be doing earlier.<p>

So  again like we stated before these are not really laws;  these are general observationsthat has been made admittedly in the course  of a fairly comprehensive empirical studythat was done by these two people.<s> so they are again they are generally applicable to veryvery  large systems,  they are applicable to systems  that are developed by hand based onsome specification you know these are not things  like computer games  and so on butthese are enterprise system that tend to run large companies like the financial systems oflarge companies and so on.<p>

(Refer Slide Time: 17:53 min)<p>

Also,  it is not clear how these  things end up applying to,  for example,  shrink wrapsoftware product.<s> shrink wrap products are those that you go out,  buy  in a store,  comeback  and install and  it works;  things like virus scan,  things like Norton utilities forWindows  those are examples  of shrink wrap products  and systems that incorporatesignificant number of COTS  component what it really means are those that built out ofintegrating  a  lot of pre-existing pre-built components  rather than systems  that has beendeveloped from scratch without any large degree of reuse with systems built and used invery small organizations, medium size systems and so on.<p>

So  to take  you have to take this  study with  a grain  of salt but largely what they say  iscommon  sense and you see this for yourself as you get involved in the evolutionmaintenance of these systems.<p>

So  let  us  look  into the first two categories of change or the two strategies that wediscussed earlier.<s> Remember,  software maintenance was one of the categories andarchitectural transformation was the second one;  the third one is  the softwarereengineering which is something that we will not go into today or during the course thiscourse but it is  something you can study for yourself; there are  several books that havebeen published in the notion of software reengineering, business process engineering andso on.<s> So we will focus mainly on the software maintenance and architecturaltransformation, kinds of changes that get introduced.<p>

(Refer Slide Time: 19:14 min)<p>

So what exactly is maintenance?We said that maintenance was primarily, it had to do which small changes, they had to dowith new requirements and so on.<s> So, maintenance fundamentally is changing a programafter it has been put into place; that is the basic definition of maintenance.<s> And like wesaid before, it is constrained to smaller changes and there is no defining line or a rule tosay you know anything more than thirty lines of code for example is a large change andanything less than thirty lines is a small change.<s> So this is something that is best done bygut feel; if you feel that it is going to change the underlined design of a system and it isno longer a maintenance issue at that point; it is an evolution issue, it is a re-architectingkind of an issue and you have to treat it differently as well.<p>
