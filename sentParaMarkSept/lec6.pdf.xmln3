This development process typically has as its interfaces between the various phases.<s> Theanalysis document is created, and then the document is read by the designer.<s> He producesa design document that is read by the developer.<s> He then produces an implementation.What this lends itself to is,  these people, developer/analysts  end up trying to interpretwhat has been written down on a piece of paper or within a document and thatinterpretation can vary from person to person.<s> If there were means to take therequirements verified and then transform the requirements automatically into code whichis the end product of the software development process.<s> That  would essentially ensurethat we retain the continuity between the various phases of the software development lifecycle.<s> And that is what transformational development means.<s> What it is trying to focus onis the idea of taking a requirement specification which has been specified formally,verifying it for consistency then generating the design from it.Allow a human to verify the design and then generating the code from that point onwardsgenerating the test from the specification, testing the code against the specification.<s> All ofthis can be automated or it can be controlled through machine tools which will essentiallyensure that the human ambiguity that is brought into the picture because of personsreading the specification or reading the design document and then producing analysis, orproducing implementations and that variability will get taken away.<s> And every time thereis consistent  transformation that is taking place from a  specification to a  piece of codewhich is really what we are after, the end of the day.<p>

Finally program verification refers to checking or testing to make sure that what we havebuild indeed conforms to the specification that was given to us in the first step.<s> Programverification also can be automated when we use formal methods because test cases can begenerated from the specifications themselves and the test cases can then be appliedagainst the final end product of the process which is a code.<s> This can help us verifywhether it indeed conforms to the specification that was set out at the beginning of theprocess.<s> One of the things or caveats that we have to keep in mind is as we go along thispath, is that formal specifications or formal methods in general have not taken of the waythat they were predicted to say way back in the late seventies and the early eighties.<p>

(Refer Slide Time: 11:44)<p>

A  lot of hope was being held out at that point of time that these would become mainstream software development methodologies.<s> But so far they have not happened and weshould kind of take a look at some of the reasons why this is the case before we get intothe techniques and how we are going to end up doing this.<s> The first reason for this is that,other software engineering techniques have been catching up with respect to increasingthe efficiency as well as decreasing the number of  errors introduced in the softwaredevelopment process.<s> One of the advantages of the formal specification is that humanscannot introduce errors into this process because they are not really as involved like  inalternative software development methodologies practices.A lot of other techniques have come up; especially process based techniques that can helpcontrol system quality and keep it under check.<s> So the needs for formal methods havecome down, but that is not really a primary reason for this.<s> The more important reason isthat formal methods have kind of failed to scale to  really large systems.<s> In order toformally specify medium sized enterprise class system like an ERP system, it would takea quite a bit of  mathematical expertise which is largely  absent from the industry, eventoday.<p>

As a result of which formal methods have primarily been tried away from, although theyhave been applied in critical systems which is where  we will see the main applicabilityhas been.<s> So the scope is kind of limited they are not very well suited for example also toanalyzing or specifying a front end GUI based systems.<s> They are primarily very good atback end system specification, but lots of systems today are GUI driven.<s> Also the marketfactors  and  market changes is something that we cannot underestimate.<s> As dictated thetime to development or the time  to market is really short because of the competitionaround us and the need for getting these systems into production very fast has  kind ofdriven that.<p>

Formal methods take a quite bit of time to develop because it is focused on doing the jobright in the first go as supposed to an  incremental method of evolution, where errors orbugs are found and fixed as the system evolves rather than a system being perfect fromthe word go.<s> The use of formal methods because of all these reasons has a certain limitedpractical applicability at this point in time.<s> Although the principle benefits are primarilyin the areas of reducing number of errors and they are primarily applied in the area ofmachine critical systems.<p>

(Refer Slide Time: 14:50)<p>

A  good example  would be software that runs avionics,  software that runs large planesthat you are flying today is all formally tested.<s> Certain part of the software at least, thesmaller parts which are very critical, something like the parts that controls the rudder orthat controls the breaking and so on is formally tested.<s> The critical pieces of software areessentially built using formal specifications and formal methods.<s> The rest of the system isbuilt using regular software engineering processes and practices and these are puttogether.<p>
