So the operations are mainly being defined as modifications to the state and the state iscentral to the model based approach whereas the operations themselves are  interfacespecifications and ex-humatic specifications those that are sent to the algebraic approach.Of course both of them do have the node.<s> The formality really is introduced by the notionof axioms in the case of algebraic approach and by the notion of invariants in the case ofmodel based approach.<s> There is a  degree of similarity exists between these twoapproaches.<s> But the difference mainly is that the model based approach is primarily statebased, whereas the algebraic specifications approach is primarily based on the operationalsignatures of the various functions that are going to make up the interface of the modulethat is being specified.<s> For formal specification there are several languages evolved overa course of time as can be seen from this slide and we have kind of categorized thedifferent languages into four different categories.<p>

(Refer Slide Time: 18:50)<p>

The first category is that of the specification languages those focuses on sequentialprograms and is  algebraic in nature.<s> The two primary languages in this category areLarch and OBJ.<s> When you move to concurrent languages there are fewer languages inthis case using algebraic specifications and concurrency essentially introduces the notionof multiple modules working together at the same time.<s> Whereas  in model basedapproaches, the quite popular  ones are Z and  VDM  that you  might have  heard ofbefore and, CSP and Petri Nets in the case of concurrent approaches.<p>

One of the things that we have to be aware of before we dive in to the details here is that,formal specification involves investing a lot more effort upfront, because you are takingtime to mathematically model the constructs.<s> It takes a lot more time in the early phase ofthe software development.<s> Whereas it will ease out  in  the later phases becausetransformational development is the focus of formal methods,  whereas hand  basedmanual development is really the focus of other software engineering practices.<s> So it alsoends up reducing a lot more errors over the life cycle of the software, because of theverification steps that are done upfront and the consistency checks that are performedupfront and the inconsistencies or the incompleteness that may exist within thespecification, for example the lack of a context defining a certain term can be removedupfront early in the lifecycle or can be restored or resolved.<p>

(Refer Slide Time: 20:20)<p>

In terms of the overall life cycle if we take a look at how the cost gets spread out, here isthe slide which shows the comparative differences of time that is spent on specificationversus design implementation, validation with and without formal specifications.<p>

(Refer Slide Time: 20:55)<p>

It can be clearly seen that in the case of formal specifications a lot of time is spent in thespecification itself,  and not as much time is spent in the design and implementationbecause it is transformational in nature.<s> And validation is also fairly simple to do.<s> In thecase of building software without the use of formal methods, specification does not takea whole lot of time,  because it is done using natural language, whereas the designimplementation, the validation phases are the ones ends up taking most time.<s> One otherthing that is not shown here is the fact that the numbers of errors that get introduced in asoftware development life cycle without formal specification are quite high.<s> The cost oferror as you go down in the process, it gets more and more expensive to fix.<p>
