(Refer Slide Time: 03:15)<p>

In fact todays project do not even last thirty months as before.<s> More than 70% of the costfrom the overall total cost of the software was taken up by the maintenance.<s> Whichmeans finding a bug, figuring out the solution and correcting the defect in the software aswell as making small changes because of incremental requirements was very expensive.There were certain factors that we are going to go through today as why that occurs so.<p>

The quality of the software itself was quite pathetic in the sense that there were  lot ofproblems and issues of the software,  there were lot of stability issues,  there were lot ofease of use issues, there were maintenance issues, there were performance issues andthere  were functional correctness issues that it would not conform to the specificationsthat were written out when this entire project was started.<s> Let us see  some moreperspective on the software crisis.<s> I am taking a survey of the US defence projects in theeighties; they kind of broke it up into several categories.<p>

(Refer Slide Time: 04:30)<p>

Among those, the first category is  really large projects which were  over  $2.5 millionoverall, most of these were not delivered at all.<s> Over  85 to 90%  of these projectseventually where not delivered and they became so late that the projects got cancelled.The second class of projects just slightly smaller than these was delivered, but they werenever used.<s> They were never used because of various reasons.<s> The quality of the softwarewas a major reason amongst them.<s> Then if you go down,  you see that some of theseprojects were completely abandoned or had to be reworked from scratch.<s> Basically, thenext category of projects which fell into the $1.5 million to $2 million range, pretty muchhad to be reworked from scratch because they do not conform to the specification.<s> It tookso long to complete the project that the requirements have changed in mean while and soon.<p>

It was noticed that only very small projects, relatively small by those standards were usedbecause they fit the requirements appropriately, but  they were  still significantly overbudget.<s> There  were nothing ever delivered on time and under budget in those days.<s> Soexperiences such as this, essentially gave rise to the term the software crisis and peoplewere wondering as to what were the causes behind the lack of quality within the software.In fact as a humorous aside Bryan Russell  has come up with these laws  of SoftwareRelativity  as he calls them.<s> Again  these are not exactly laws, but kind of illustrate  thepoint that it is trying to make about the software.<s> The first thing says that as the softwareproject approach its release the mass increases, that is the number of people that end upbecoming a part of the project goes up dramatically.<s> The energy required to release thesoftware project is inversely  proportional to the time before a  scheduled  release and soon.<s> You can read the rest of these in the screen shot below.<p>

(Refer Slide Time: 06:24)<p>

What these are basically trying to put in perspective is the software crisis that wasoccurring in the  eighties.<s> Every time the project got delayed, there are lot of people gotput on to it, there were manpower issues on this and that was not the way to solve thislike Fred brooks also said in the late eighties adding people to a late project is only goingto make it more lately.<s> What are the properties of failing software?<s> It is worth while totake a look at some of the causes that led to these kinds  of failures,  and  that led to thepoor quality of the software that was being produced in those days.<p>

One of the first things that come up in this list is redundancy.<s> Redundancy is basicallyreferring to the fact that in a software project most of the code or the development takesplace from scratch.<s> And there is very little reuse of components that are taking place.How the redundancy affects the quality?<s> Every time you write code, it has to be testedthoroughly and the number of testing combinations that are going to exists depending onnumber of input parameters that piece of module is going to take, it tends  to beprohibitively large.<s> As a result of which, either statistical techniques are employed or thesoftware is not very well tested.<p>

(Refer Slide Time: 09:30)<p>

If we had reused and we were using pre built component that had been used in productionsituation several times  before and you could be reasonably sure that these componentscould handle whatever  is going to be thrown at them,  because they had not just beentested, but they also be used in other applications.<s> But that does not happen very often insoftware.<s> There is a very high degree of inter-connectedness between the modules.<s> Thisleads to a term called fragility of software and fragility basically refers to a fact that asmall change that needs to be made is going to end up costing a lot in terms of time, interms of effort, and in terms of money.<s> This is because of the high degree of coupling thatexists between the so called modules within the software.<p>

Typically, a well modularized piece of software is supposed to have a very low degree ofcoupling between these two as we shall see going forward.<s> One of the reasons whymaintenance was so hard and it took so  long to fix an issue or to add  a certainrequirement was the low understandability.<s> The low understandability of the softwarecame about because of the couple of reasons.<s> One was that the abstractions were simplynot there within the code.<s> So there was lack of encapsulation.<s> There was spaghetti codeall over the place.<s> Procedural abstractions were  being used.<s> Procedural  abstractionsbasically consist of set of functions or set of global data that these set of functionsmanipulated and that just was not going to cut it as far as a second programmer who didnot write the original piece of code trying to understand,  makes sense of the spaghetticode and now he had to make changes in this environment.<s> Of course documentation wasalways obsolete because software was changing much faster and the processes were notbeing followed.<s> But that is not a focus of our talk here today.<p>

Lastly, there were human factors.<s> A human factor was man power estimation was closelyinadequate.<s> There was no effort estimation technique.<s> But those are things that you havealready seen so far in the course, in terms of how to attack a process,  how to deal withman power estimation,  how to deal with effort estimation of module and so on.<s> Againthat is some thing that we are not really going to get into in this particular lecture.<s> Theseproperties and the common error in managing the process of software development  arewell illustrated by this chart.<s> What is this trying to show is that on the x axis  is,  thefunctionality that is being added and on the y axis is the quality properties of thesoftware.<p>

(Refer Slide Time: 10:01)<p>

Things like robustness of software,  the unit testing of the software, correctness,performance etc which are basically the qualities of non functional requirements.<s> As theproject went on suppose there were early releases before the project actually completedand these points indicate early releases.<s> What normally happened was a lot offunctionality was added initially all the way up to the point that the project came to itsclose and then all the testing and debugging got done in the last part of the project.<s> Lot ofthe code was added without adequate testing getting  done  without  adequate attentionbeing paid to performance, being paid to ease of use, being paid to structural integrity ofthe software and so on.<p>

Then most of the debugging took place in the last phase whereas what is actually desiredis something that will set up the quality frame work very early in the process and thenyou add the functionality as you go along.<s> You can make the same releases,  with thesame amount of functionality or to have lot more quality to it and that  is the desiredprocess  which is shown as the pink colored line in the graph.<s> Here is another  exampleabout how lack of encapsulation hurts maintenance.<p>

(Refer Slide Time: 11:20)<p>

Typically we have seen this chart before in terms of what is the  break down ofmaintenance cost,  where are the most bugs filed,  where  are  the most change requestscoming from.<s> There  are  the  only two important categories in this chart.<s> The first onewhich is the largest category is the change in user requirement and it cost the most.<s> It isnot due to lot of changes, it is because of every change is very expensive to handle, it isbecause the software is fragile and  not easily amendable for  extension  or  not easilychangeable or flexible, this happens.<p>

Because the lack of  encapsulation and lack of abstractions  a change in the data formatthis is surprising statistic that almost twenty percent of the maintenance cost come fromchanges in data formats taking place.<s> The Y2K bug is the famous example or infamousexample of this.<s> What are the quality factors in software that we need to be watching outfor?<s> The quality factors can be divided into two main categories.<p>

One is external.<s> External implies that it is visible to the user.<s> Obvious example of this isperformance.<s> Ease of  use is another example.<s> The other factors are driven by internalneeds, such a robustness of design.<s> If I want to add a feature to the software, what is itgoing to cost me to do?<s> This is driven by the robustness of design, flexibility of thedesign, openness of the design, software portability to other platform and documentationof the code etc.<s> What building quality software is, the process, the mind set which isthinking about the internal factors and focusing on the internal factors in order to ensurethat the external quality factors are being met.<s> Basically, it is only the structural softwarewith structural integrity that is going to allow you to make these changes quickly andwhich is going to allow you to give the kind of the performance that user is going toexpect of this software.<p>

(Refer Slide Time: 13:35)<p>

It  can also be thought of as functional properties of software such as profit,  customerorientation etc  versus the structural properties of software which basically lead  towardscost reduction.<s> That was the categorization of quality features and if we actually dive intothe quality factors themselves, correctness appears at the top of the list as it is to beexpected.<p>
