===========================================================
Software EngineeringProf.<s> Rushikesh K. JoshiComputer Science &amp; EngineeringIndian Institute of Technology, BombayLecture - 20Structural Programming &amp; SomeImplementation Aspects<p>

In this lecture we will look at structured programming and some implementation aspects.Let us see what structured programming is and how it is originated and how it has beendeveloped into a full fledged methodology for software design and modulardecomposition.<s> We will mainly look at the core concepts or core ideas behind structuredprogramming.<s> So what is structured  programming?<s> Basically,  we look at modularstructural decomposition in a top down fashion.<p>

(Refer Slide Time: 01:35)<p>

So, when we want to design a system, we have seen during our design lectures that, weneed to defeat the complexity by decomposing a big system into smaller units or smallermodules which interact or collaborate.<s> This decomposition can be done in a top downfashion such that different concerns of the program are implemented as different subsections or modules which are structured in a top down fashion.<p>

What is the advantage of this top down decomposition?<s> The third bullet list in the aboveslide shows some of the benefits that you get through this top down decomposition.<s> Firstthing is that everybody follows fixed  style.<s> If you follow different rules of structureprogramming that are laid out, the programs becomes clearer  and  the designs also haveclarity due to the top down approach.<p>

So, at the top level you understand the top level concern.<s> Whereas you can zoom on to atop level concern and then you get into the smaller units which are further refinements ofthe higher level aspect or the higher level module.<s> So, clarity improves because you caneasily conceive concerns at higher level or the aspects at higher level with the higherlevel modules.<s> And as you go down the low levels you have the smaller abstractions.<s> Forexample, you may have higher level function to perform a transaction.<s> But the transactioncan be broken down into different sub transactions  and at high level you need tounderstand what are semantics or what do you send as input and what do you expect asoutput.<s> Whereas lower level you can further see how  the  bigger transaction can beimplemented or can be decomposed into different sub transactions.<p>

Thus clarity, productivity,  ease of testing, maintenance and ease of redesign are variousbenefits that you can get through by following structured style or following the structuredprogramming practices/methods.<s> We are going to look at what exactly structuralprogramming and from where does it come about, what are the basic ingredients ofstructured programming that gives you from lower level programming to higher levelstructure or in to higher level decomposition which can also be structured.<p>

So why does productivity improve?<s> It improves  because you are able to decomposenicely independent concerns with single entry and single exit criteria.<s> If you are able todecompose different concerns independently and then compose them together to formbigger modules or bigger constructions such as, bigger functions or bigger objects and soon.<s> So it improves productivity in the sense,  people are focused on independentcomponent and once you are done with a component,  if it follows various wellestablished principles behind modular design we can reuse them.<s> We  can reuse theexisting components, we can reuse develop components again and again, and that leads tosome of these aspects such as higher productivity.<p>

Ease of testing: It is easy to test independent modules and then take concerns or handleconcerns one by one.<s> Easy maintenance:  If something is wrong with a module,  you cansimply  replace that if there are no side effects and so on.<s> Similarly ease of redesign.Maintenance and design also becomes easier once the methodology is followed.<s> So, theheart of structured programming is the idea of using only the single entry and single exitblocks.<s> After having introduced to some of these advantages of structural programming,we will see where they came about from.<s> But the basic concept that we have to look at isthis  single entry  and  single exit blocks.<s> In this lecture we are going to focus on lowlevel concepts of implementation such as individual statements and not the high leveldesign aspects which we have seen in some of our earlier lectures on design andarchitecture.<p>

So during top down decomposition,  design a program as a top down hierarchy ofmodules.<s> This hierarchy is developed according to various design rules and guidelinesthat we have seen earlier.<p>

(Refer Slide Time: 06:37)<p>

The modules are evaluated as per the quality acceptance criteria to ensure the bestmodular design of the program.<s> So you have to again evaluate the modules as per yourquality acceptance,  different criteria metrics and so on.<s> We are going to have speciallecture on metrics and some of these criteria of modular design and modular measures ofmodularity  such as how good your design  is,  how good your modularization is.<s> Themodules are implemented using basic structured programming principles which are goingto be focus of this lecture.<p>

Modular design leads to modular packaging.<s> When you do design in modular fashion, itshould result into code or packaging of your software which is also modular.<s> So that, it iseasy to handle the software as a distribution package or the release of the software interms of its modules, its files and its configuration that you need to do for installation andso on.<p>

(Refer Slide Time: 07:33)<p>

So the modular design is basically group of executable instructions with a single point ofentry and single point of exit.<s> In the group there are many modules and which againfollow the structured programming principles.<s> And the packaging is your actual assemblyof data such as, your files, processes, modules, packages (Example: java packages), yourinterfaces such as in your middleware you will look at the IDLs and even your hardwareor machine.<s> You need to install or you need to deploy your different software modules onto different machines, over the network and so on.<p>

So, the packaging aspect is also important and along with the design which your logicalconstruction of your software.<s> Basically, the actual physical deployment where youactually place these modules is also important.<s> And a structured modular design can leadto good modular packaging where you can use the packaging abstractions of your givenimplementation paradigm.<s> Say for example if you are using C or C++ you can use yourhash include files to define your modular interfaces or different modules and keep themindependent and have all of the modules implemented in different files.<s> And also forexample, for each module which has various functions or has  its own functions,  can beimplemented in different  C  program and you can separately compile them.<s> So,  usingseparate compilation, you can keep concerns differently.<p>
