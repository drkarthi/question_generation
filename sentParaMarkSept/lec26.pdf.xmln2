(Refer Slide Time: 11:02 min)<p>

So  an iterative process is basically very similar to the spiral model of development thatyou have seen earlier during lifecycle models and even there the focus is on trying toiterate over small amounts of requirement and go to the complete software developmentlifecycle with that small sort of requirements, come back, get user feedback and then startwork on the additional set of requirements that may exist and the iterative process is veryvery similar except that the frequency with which this  cycle  occurs or  repeats  will bequite high compared  to the spiral development models.<s> So  there are many moreincrements; in fact an increment would be something as small as a single single small setof requirements which is called a story which we  will see as we go down to  the rest ofthis presentation.<p>

So what it is that is so good about the iterative development process and that is somethingthat we would like to look at next.<s> What are the advantages of such a process and whatare the disadvantages of such a process.<p>

(Refer Slide Time: 12:08 min)<p>

The  obvious advantage is that there is an accelerated delivery to the customer.<s> So thecustomer is going to get something in their hands pretty quickly; it may not be the wholesystem but it is something that they can use to give feedback to the software developmentteam and they can also see for themselves if this is the system that they want to develop;it is progressing in a way that they believe is right  for their  needs.<s> So every incrementessentially delivers the feature set that is the highest priority of the customer.<s> So thecustomer evaluates that and  gives  immediate  feedback and that itself is anotheradvantage; the user is always engaged with the system so it is not possible.<p>

For  example,  in this process for you to go off  into a  corner,  do development of a largesystem completely then come back to the user and then the user figures out oops!<s> this isnot what I wanted at all, this is entirely wrong; I think I will have to restart specifying thesystem; that cannot happen in this process because they are going to see something veryquickly; in fact they are not just going to see sketches of user interfaces but they will seean entire system which they can actually work with, which they can actually experiencewith, which they can play with and then they give feedback to the users; I mean feedbackback to the software development team.<s> So the users are  very committed in this  entireprocess and that is a very very big advantage of the process.<p>

Also, it is very likely that as the user sees the system as it is being delivered to them theymight change the requirement so that eventually the end product that is delivered to thecustomer exactly meets the needs that they do have.<s> On the other hand, the system alsopresents certain disadvantages.<p>

Disadvantages are there can be serious management problems with this process, progresscan be very very hard to judge because of the levels of increment.<s> So, suppose there aremedium size systems, it  has twenty to twenty five increments  that have to be donesometimes  increments are as short as one to two weeks in nature so a  system thatoriginally took may be a year or two years to build  would have like close  to  hundredincrements and to keep track of all these increments and whether progress is eventuallybeing made towards the overall goal of delivering the software product to the customer isa hard thing to do because the customer is allowed to change the requirements on a perincrement basis that is one thing.<p>

Also, the focus is not on documentation and as long as there are no design documents itmay start getting hard to judge exactly what has been done up to date and  what is theamount of work that is remaining to be done.<s> There can be contractual problems that leadout of this process the same thing and different forms of contracts may have to be usedbecause a typical contract would say here is the specification of a system to be built andthis is what it is going to cost in terms of time and money to build these many numbersand people who are going to be use the resources that are going to be required and so on.But that process is not as clean in the case of agile development.<s> Here it says you knowfor one increment it is pretty clear what you are going to do; it is a set of well-specifiedrequirements as far as one increment is concerned.<s> But it is hard to keep signing contractson per increment basis; the contract has to be for the period of development of the entiresoftware project and it is hard to do that here.<p>

(Refer Slide Time: 15:36 min)<p>

Again,  validation problems can also exist.<s> Since  there is no real specification thespecification keeps changing.<s> there is no single body of specification in which validationcan be done as a  result of which validating whether you are on the  right  track can be alittle hard.<s> This is mainly done informally  because  of  the user feedback and that isactually a plus that works very well but there is no formal method of validation,verification  that  can be applied in this process  and certainly the complexity of thesoftware tends to grow over a period of time because of  all the changes that are  beingmade to it constantly; during every iteration you may end up adding to the code, you mayend up modifying existing code because of the additional requirement that you are takingand so on as the result of which designs may not be very clean and the complexity of thesoftware may grow to a point where maintainability becomes a real issue  and  that issomething  that  you  have to  watch out for in this case.<s> Now  very similar to the lines ofwhat is called iterative development is another process called prototyping.<p>

(Refer Slide Time: 16:41 min)<p>

Software prototyping: you probably heard of this during the earlier versions in this courseand  prototyping is very similar to incremental development it  does  not  really focus ondelivery to a customer.<s> What it essentially is is a technique for the software developmentteam to satisfy themselves that they have made some progress in the right direction here.It can also be used to get feedback from the user but its prototype is not an entity that iseventually going to be given to the user for them to keep.<p>

Also, a  prototype could be something that is purely  front end sketch  of the system forexample,  it may just contain dummy  user interfaces that do  not  actually end up doinganything  in  terms of  business logic for  example,  may not be coded  in the case ofprototype.<s> So, from very large systems iterative development can prove to be a hindranceas we have seen because of some other disadvantages and because of the impracticality ofusing iterative development we might need to resort  to some other means  and soprototyping is the best way of doing that.<p>

Prototyping is basically a process where experimental systems are developed; it  may ormay not be used;  typically prototypes are thrown away before real system developmentstarts  and they may be used just validate certain proof of concepts,  certain design ideasthat are going to be used in eventual software.<s> So a prototype is just an initial version of asystem by definition and it is used to demonstrate concepts as we just said and it can beused in several different situations;  it can be used,  for example,  in the requirementsengineering process to help out in the requirements elicitation so what it does here is thatthe user is trying to specify  let us  say a user interface need that he has so the  systemneeds to give me a form to enter some data or let us say  it is a  banking system or afinancial system and it needs to give me a form to enter some data; I do not know whatthe form is going to look like so I cannot really say how much of data I want to collect offfor that form.<s> Whereas  UI  prototype  or a user  interface prototype can quickly bedeveloped,  the form can be shown to the user and the user can make some adjustmentsbased on that.<s> They can also realize whether they are going down in the wrong path andthey can completely change the requirement.<s> So,  very early on prototypes can be veryvery useful in trying to ensure that the system requirements are done correctly.<p>

(Refer Slide Time: 18:20 min)<p>

Certainly it is also useful in the design process because there could be a proof of conceptyou are trying to validate.<s> For  example,  you are trying to use triple desk  security in asituation which may or may not require that.<s> Also, triple dusk security may require lot ofprocessing power; the system is supposed to run on a CPU of 1.8 GHz only because thatis the requirement from the user so here is a design decision that you have to make as towhich security protocol are you going to end up using or you are going to use triple desksecurity or you are going to use RSA etc etc and this maybe can only be validated withthe help of a  prototype so you actually put that in there,  you do a quick  performancestudy to see whether RSA processing is going to take too much time or not and if not youplug in a different security algorithm into that situation and pick the right one that will fityour need.<s> So, that is an example of using prototyping in the design process and certainlyin the testing process, well, to run back to back tests so you can essentially validate someideas through the prototype you can also run the same test on the real system and then doa comparison to see how these two behave and is the prototype doing something that isacted according to the user and the real systems feeling those steps so there must be someproblem.<p>
